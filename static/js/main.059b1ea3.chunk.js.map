{"version":3,"sources":["components/RectFill/RectFill.js","App.js","diagnostics/reportWebVitals.js","index.js"],"names":["RectFill","props","wrapperRef","React","state","dimensions","eventListenerAttached","this","padding","ratio","inners","width","height","sideLength","Math","min","style","position","left","top","className","children","console","log","ref","window","addEventListener","setState","current","getBoundingClientRect","prevProps","prevState","snapshot","removeEventListener","gameToPercent","topBound","botBound","distToPaddlePlane","distToDeathPlane","paddleWidth","puckRadius","App","countdownVal","keysDown","Set","tickInterval","paddle1Pos","paddle2Pos","xPuck","yPuck","xVelecityPuck","yVelecityPuck","scoreLeft","scoreRight","e","keyPressHandler","keyDownHandler","keyUpHandler","setTimeout","add","key","delete","makeBorders","resetGameVars","setInterval","tick","clearInterval","abs","puckStartSpeed","random","has","max","newX","newY","bounceY","bounceX","forceUpdate","slope","projectedIntersectionX","xAfterBounce","distToCenterPaddle","xPos","yPos","xSpeedBounceX","ySpeedBounceX","xVel","yVel","percentMoreToTravel","projectedIntersectionY","oldSpeed","scaleLine","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.059b1ea3.chunk.js","sourcesContent":["import * as React from 'react';\r\nimport './RectFill.css';\r\n\r\n// square/rect fills\r\n//  ratio is width/height\r\nclass RectFill extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n\r\n        this.wrapperRef = React.createRef();\r\n        this.state = {\r\n            dimensions: null,\r\n            eventListenerAttached: false,\r\n        };\r\n    }\r\n    render(){\r\n        // ratio is width/height\r\n        const {padding = 0, ratio = 1} = this.props;\r\n        const {dimensions, eventListenerAttached} = this.state;\r\n\r\n        let inners = null;\r\n\r\n        if(eventListenerAttached && dimensions !== null){\r\n            const {width, height} = dimensions;\r\n\r\n            if(width && height){\r\n                const sideLength = Math.min(width/ratio, height);\r\n                const style = {\r\n                    position: 'absolute',\r\n                    width: `${sideLength*ratio - 2*padding}px`,\r\n                    height: `${sideLength - 2*padding}px`,\r\n                    left: `${(width-sideLength*ratio)/2 + padding}px`,\r\n                    top: `${(height-sideLength)/2 + padding}px`,\r\n                };\r\n\r\n                inners = (\r\n                    <div style={style} className={this.props.className}>\r\n                        {this.props.children}\r\n                    </div>\r\n                );\r\n            }\r\n            else {\r\n                console.log(`SquareFill error, found width/height to be: [${width}, ${height}]`);\r\n            }\r\n        }\r\n\r\n        return (\r\n            <div ref={this.wrapperRef} className={'rect-fill-js-wrapper-style'} >\r\n                {inners}\r\n            </div>\r\n        );\r\n    }\r\n    componentDidMount() {\r\n        window.addEventListener(\"resize\", () => {\r\n            this.setState(() => ({dimensions: this.wrapperRef.current.getBoundingClientRect()}));\r\n        });\r\n        this.setState(() => ({eventListenerAttached: true}));\r\n    }\r\n    componentDidUpdate(prevProps, prevState, snapshot) {\r\n        if(this.state.dimensions === null){\r\n            this.setState(() => ({dimensions: this.wrapperRef.current.getBoundingClientRect()}));\r\n        }\r\n    }\r\n    componentWillUnmount() {\r\n        if(this.state.eventListenerAttached){\r\n            // this.wrapperRef.current.removeEventListener(\"resize\", () => {\r\n            //     console.log('resize');\r\n            //     this.setState(() => ({dimensions: this.wrapperRef.current.getBoundingClientRect()}))\r\n            // });\r\n            window.removeEventListener(\"resize\", () => {\r\n                console.log('resize');\r\n                this.setState(() => ({dimensions: this.wrapperRef.current.getBoundingClientRect()}));\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport default RectFill;","import * as React from 'react';\nimport RectFill from \"./components/RectFill/RectFill\";\nimport './App.css';\n\n// states\n//  constants so don't have to shift the numbers around\nconst welcome = 0;\n//  shift\nconst transitionA = 1;\n//  zoom\nconst transitionB = 2;\nconst countdown = 3;\nconst playing = 4;\nconst gameEnded = 5;\nconst credits = 6;\n\n// game constants\nconst winScore = 7;\n//  1 game unit -> 'gameToPercent' percents\nconst gameToPercent = 0.05;\n// all below in game units\n//  the right eye starts slightly high in the beginning\nconst rightEyeStartOffset = -1.75/gameToPercent;\nconst leftEyeStartOffset = 0.85/gameToPercent;\n//  game bounds\nconst topBound = -35/gameToPercent;\nconst botBound = 40/gameToPercent;\n//  left: 23% on puck puts puck center on edge of paddle, TODO: when in use subtract puckRadius\nconst distToPaddlePlane = 23/gameToPercent;\n//  same as above but death (scoring) plane\nconst distToDeathPlane = 23.9/gameToPercent;\n//  paddle width - from center to edge is 'paddleWidth'/2\nconst paddleWidth = 27/gameToPercent;\n//  radius of puck\nconst puckRadius = 2.5/gameToPercent;\n\n// game speed constants\nconst ticksPS = 60;\n// horizontal\nconst puckStartSpeed = -14;\nconst puckMinSpeed = 14;\n// vertical\nconst paddleSpeed = 17;\nconst aiPaddleSpeed = 12;\n// controls the physics of ball bouncing off the paddle\nconst vertSpeedConservation = .4;\n// desmos: Kaguya Pong\n//  s = 'scaleLine'\n//  f1 = how much ySpeed the ball gets\n//  f2 = how much xSpeed the ball gets\n//   x-axis = distance from paddle center in percent\n//   y-axis = speed\n//  formula:\n//   ySpeed = oldYSpeed*vertSpeedConservation + f1\n//   xSpeed = (-oldXSpeed) + f2*horzSpeedMod         (min of minSpeed)\nconst scaleLine = 40;\n// we want x speed to be slower than y speed since more space\nconst horzSpeedMod = 1/2;\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            state: welcome,\n            countdownVal: -1,\n        };\n\n        // for handlers\n        this.keysDown = new Set();\n\n        // game variables\n        this.tickInterval = null;\n        this.paddle1Pos = null;\n        this.paddle2Pos = null;\n        this.xPuck = null;\n        this.yPuck = null;\n        this.xVelecityPuck = null;\n        this.yVelecityPuck = null;\n        this.scoreLeft = null;\n        this.scoreRight = null;\n    }\n\n    // event handlers\n    // setup\n    componentDidMount() {\n        window.addEventListener(\"keypress\", (e) => this.keyPressHandler(e));\n        window.addEventListener(\"keydown\", (e) => this.keyDownHandler(e));\n        window.addEventListener(\"keyup\", (e) => this.keyUpHandler(e));\n    }\n    // teardown\n    componentWillUnmount() {\n        window.removeEventListener(\"keypress\", (e) => this.keyPressHandler(e));\n        window.removeEventListener(\"keydown\", (e) => this.keyDownHandler(e));\n        window.removeEventListener(\"keyup\", (e) => this.keyUpHandler(e));\n    }\n    // handler functions\n    keyPressHandler(e) {\n        const {state} = this.state;\n\n        // press any key to continue...\n        if(state === welcome){\n            this.setState(() => ({state: transitionA}));\n            setTimeout(() => {\n                this.setState(() => ({state: transitionB}));\n                setTimeout(() => this.setState(() => ({state: countdown, countdownVal: -1})), 1200);\n            }, 1200);\n        }\n    }\n    keyDownHandler(e) {\n        this.keysDown.add(e.key);\n    }\n    keyUpHandler(e) {\n        this.keysDown.delete(e.key);\n    }\n\n    // render\n    render() {\n        const {state, countdownVal} = this.state;\n\n        if(state === welcome) {\n            return (\n                <div className={'app'}>\n                    <RectFill padding={10} ratio={1.77777777778} className={\"slow-transition\"}>\n                        <div className={\"bg-2 fill\"} />\n                        <div className={\"right-eye fill\"} />\n                        <div className={\"left-eye fill\"} />\n                        <div className={\"text\"}>\n                            PRESS START\n                        </div>\n                    </RectFill>\n                </div>\n            );\n        }\n\n        else if(state === transitionA) {\n            return (\n                <div className={'app'}>\n                    <RectFill padding={10} ratio={1} className={\"slow-transition\"}>\n                        <div className={\"bg-2 fill fill-transition\"} />\n                        <div className={\"right-eye fill fill-transition\"} />\n                        <div className={\"left-eye fill fill-transition\"} />\n                    </RectFill>\n                </div>\n            );\n        }\n\n        else if(state === transitionB) {\n            return(\n                <div className={'app'}>\n                    <RectFill padding={10} ratio={1} className={\"hide-overflow\"}>\n                        <div className={\"bg-2 fill fill2 fill-transition\"} />\n                        <div className={\"right-eye fill fill2 fill-transition\"} />\n                        <div className={\"left-eye fill fill2 fill-transition\"} />\n                    </RectFill>\n                </div>\n            );\n        }\n\n        else if(state === countdown) {\n            // Countdown\n            if(countdownVal === -1){\n                this.setState(() => ({countdownVal: 4}));\n\n                setTimeout(() => {\n                    this.setState(() => ({state: playing}));\n                }, 1000);\n\n                // setTimeout(() => {\n                //     this.setState(() => ({countdownVal: 3}));\n                //     setTimeout(() => {\n                //         this.setState(() => ({countdownVal: 2}));\n                //         setTimeout(() => {\n                //             this.setState(() => ({countdownVal: 1}));\n                //             setTimeout(() => {\n                //                 this.setState(() => ({countdownVal: 0}));\n                //                 setTimeout(() => {\n                //                     this.setState(() => ({state: playing}));\n                //                 }, 1000);\n                //             }, 1000);\n                //         }, 1000);\n                //     }, 1000);\n                // }, 1000);\n            }\n\n            return(\n                <div className={'app'}>\n                    <RectFill padding={10} ratio={1} className={\"hide-overflow\"}>\n                        <div className={\"bg-2 fill fill2\"} />\n                        {this.makeBorders()}\n                        <div className={\"right-eye fill fill2\"} />\n                        <div className={\"left-eye fill fill2\"} />\n                        <div className={\"puck fill fill2\"} />\n                        <div className={\"text textGame\"}>\n                            {((countdownVal === 4) ? (\"READY\") : (countdownVal))}\n                        </div>\n                    </RectFill>\n                </div>\n            );\n        }\n\n        else if(state === playing) {\n            // start playing\n            if(this.tickInterval === null){\n                this.resetGameVars();\n                this.tickInterval = setInterval(() => this.tick(), 1000/ticksPS);\n            }\n\n            return(\n                <div className={'app'}>\n                    <RectFill padding={10} ratio={1} className={\"hide-overflow\"}>\n                        <div className={\"bg-2 fill fill2\"} />\n                        {this.makeBorders()}\n                        <div className={\"text textGame textScore\"}>\n                            {`${this.scoreLeft}`}<span />-<span />{`${this.scoreRight}`}\n                        </div>\n                        <div className={\"left-eye fill fill2\"} style={({\n                            top: `${(this.paddle1Pos-leftEyeStartOffset)*gameToPercent}%`,\n                        })} />\n                        <div className={\"right-eye fill fill2\"} style={({\n                            top: `${(this.paddle2Pos-rightEyeStartOffset)*gameToPercent}%`,\n                        })} />\n                        <div className={\"puck fill fill2\"} style={({\n                            left: `${this.xPuck*gameToPercent}%`,\n                            top: `${this.yPuck*gameToPercent}%`,\n                        })} />\n                    </RectFill>\n                </div>\n            );\n        }\n\n        else if(state === gameEnded){\n            if(this.tickInterval) {\n                clearInterval(this.tickInterval);\n                this.tickInterval = null;\n            }\n\n            return(\n                <div className={'app'}>\n                    <RectFill padding={10} ratio={1} className={\"hide-overflow\"}>\n                        <div className={\"bg-2 fill fill2\"} />\n                        {this.makeBorders()}\n                        <div className={\"text textGame textScore\"}>\n                            {`${this.scoreLeft}`}<span />-<span />{`${this.scoreRight}`}\n                        </div>\n                        <div className={\"left-eye fill fill2\"} style={({\n                            top: `${(this.paddle1Pos-leftEyeStartOffset)*gameToPercent}%`,\n                        })} />\n                        <div className={\"right-eye fill fill2\"} style={({\n                            top: `${(this.paddle2Pos-rightEyeStartOffset)*gameToPercent}%`,\n                        })} />\n                        <div className={\"puck fill fill2\"} style={({\n                            left: `${this.xPuck*gameToPercent}%`,\n                            top: `${this.yPuck*gameToPercent}%`,\n                        })} />\n                        <div className={\"text textGame\"}>\n                            {`P${((this.scoreLeft > this.scoreRight) ? (1) : (2))} WINS!`}\n                        </div>\n                    </RectFill>\n                </div>\n            );\n        }\n\n        // TODO: onwards\n\n        console.log(`UNKNOWN STATE IN APP: ${state}`);\n        return null;\n    }\n\n    // game functions\n    tick() {\n        // check gameover / reset paddle position\n        if(Math.abs(this.xPuck) >= distToDeathPlane) {\n            if(this.scoreLeft >= winScore || this.scoreRight >= winScore) {\n                clearInterval(this.tickInterval);\n                this.setState(() => ({state: gameEnded}));\n                return;\n            }\n\n            this.xVelecityPuck = ((this.xPuck > 0) ? (puckStartSpeed/2 * -1) : (puckStartSpeed/2));\n            this.yVelecityPuck = Math.random()*puckMinSpeed*2-puckMinSpeed;\n            this.xPuck = 0;\n            this.yPuck = 0;\n        }\n\n        // move paddles\n        if(this.keysDown.has('ArrowUp') || this.keysDown.has('w') || this.keysDown.has('W')) {\n            this.paddle1Pos = Math.max(this.paddle1Pos-paddleSpeed, topBound+paddleWidth/2);\n        }\n        if(this.keysDown.has('ArrowDown') || this.keysDown.has('s') || this.keysDown.has('S')) {\n            this.paddle1Pos = Math.min(this.paddle1Pos+paddleSpeed, botBound-paddleWidth/2);\n        }\n        //  ai\n        //  TODO: more complicated ai\n        if(this.paddle2Pos > this.yPuck+aiPaddleSpeed) {\n            this.paddle2Pos = Math.max(this.paddle2Pos-aiPaddleSpeed, topBound+paddleWidth/2);\n        }\n        else if(this.paddle2Pos < this.yPuck-aiPaddleSpeed) {\n            this.paddle2Pos = Math.min(this.paddle2Pos+aiPaddleSpeed, botBound-paddleWidth/2);\n        }\n\n        // move ball\n        //  bounce formula:\n        //   ySpeed = oldYSpeed*vertSpeedConservation + f1\n        //   xSpeed = (-oldXSpeed) + f2*horzSpeedMod         (min of minSpeed)\n        let newX = this.xPuck + this.xVelecityPuck;\n        let newY = this.yPuck + this.yVelecityPuck;\n        //  worst edge case: ball moving diagonally into corner\n        if((newY <= topBound || newY >= botBound) && Math.abs(newX) >= distToPaddlePlane-puckRadius){\n            console.log(\"corner case\");\n            const percentXToGo = Math.abs((Math.abs(this.xPuck - distToPaddlePlane)+puckRadius)/this.xVelecityPuck);\n            const percentYToGo = ((newY <= topBound) ? (\n                Math.abs((Math.abs(this.yPuck-topBound)+puckRadius)/this.yVelecityPuck)\n            ) : (\n                Math.abs((Math.abs(this.yPuck-botBound)+puckRadius)/this.yVelecityPuck)\n            ));\n\n            if(percentXToGo > percentYToGo){\n                [newX, newY] = this.bounceY(newY);\n                [this.xPuck, this.yPuck] = this.bounceX(newX);\n            }\n            else {\n                [newX, newY] = this.bounceX(newX);\n                [this.xPuck, this.yPuck] = this.bounceY(newY);\n            }\n        }\n        else if(newY <= topBound || newY >= botBound) {\n            [this.xPuck, this.yPuck] = this.bounceY(newY);\n        }\n        else if (Math.abs(newX) >= distToPaddlePlane-puckRadius) {\n            [this.xPuck, this.yPuck] = this.bounceX(newX);\n        }\n        else {\n            [this.xPuck, this.yPuck] = [newX, newY];\n        }\n\n        // check scoring\n        if(Math.abs(this.xPuck) >= distToDeathPlane){\n            this.scoreLeft += (this.xPuck > 0);\n            this.scoreRight += (this.xPuck < 0);\n        }\n\n        this.forceUpdate();\n    }\n    // helpers ball movement\n    //  return [newX, newY]\n    bounceY(newY) {\n        const slope = this.yVelecityPuck/this.xVelecityPuck;\n        this.yVelecityPuck *= -1;\n\n        if(newY <= topBound) {\n            const projectedIntersectionX = (topBound-this.yPuck)/slope + this.xPuck;\n            const xAfterBounce = Math.abs(this.xVelecityPuck) - Math.abs(projectedIntersectionX-this.xPuck);\n\n            return [this.xPuck+this.xVelecityPuck, topBound+(-slope*xAfterBounce)];\n        }\n        else if(newY >= botBound) {\n            const projectedIntersectionX = (botBound-this.yPuck)/slope + this.xPuck;\n            const xAfterBounce = Math.abs(this.xVelecityPuck) - Math.abs(projectedIntersectionX-this.xPuck);\n\n            return [this.xPuck+this.xVelecityPuck, botBound-(-slope*xAfterBounce)];\n        }\n        else {\n            console.log('ERROR IN BOUNCEY');\n            return undefined;\n        }\n    }\n    //  bounce formula:\n    //   xSpeed = (-oldXSpeed) + (-scale(dist)+scale/4)*horzSpeedMod         (min of minSpeed)\n    //   ySpeed = oldYSpeed*vertSpeedConservation + (scale(dist))\n    bounceX(newX) {\n        // paddle 1\n        if(-newX >= distToPaddlePlane-puckRadius) {\n            // only bounce if paddle is there\n            const distToCenterPaddle = (this.yPuck - this.paddle1Pos)/paddleWidth;\n            if(Math.abs(distToCenterPaddle) > 0.5+puckRadius/paddleWidth){\n                return [newX, this.yPuck+this.yVelecityPuck];\n            }\n\n            // calculate new velocities\n            const [xVel, yVel] = [this.xSpeedBounceX(this.xVelecityPuck, distToCenterPaddle), this.ySpeedBounceX(this.yVelecityPuck, distToCenterPaddle)];\n\n            // calculate the ball's new position this tick\n            let xPos, yPos;\n            //  if its already inside the paddle simply change velocities and update position\n            if(-this.xPuck >= distToPaddlePlane-puckRadius) {\n                [xPos, yPos] = [this.xPuck+xVel, this.yPuck+yVel];\n            }\n            //  otherwise simulate how the bounce would work given infinite tick rate\n            else {\n                // model how much more the puck should have traveled after the bounce\n                const percentTurnTraveled = Math.abs((distToPaddlePlane - Math.abs(this.xPuck) - puckRadius)/this.xVelecityPuck);\n                const percentMoreToTravel = 1 - percentTurnTraveled;\n                // find the x/y the puck would have hit the paddle\n                const projectedIntersectionY = (this.yVelecityPuck/this.xVelecityPuck)*(-distToPaddlePlane-this.xPuck+puckRadius)+this.yPuck;\n\n                // model where the puck would have traveled to after the collision\n                [xPos, yPos] = [-distToPaddlePlane+percentMoreToTravel*xVel+puckRadius, projectedIntersectionY+percentMoreToTravel*yVel];\n            }\n\n            // if the new position is still in the paddle, eject it\n            if(-xPos >= distToPaddlePlane-puckRadius) {\n                [xPos, yPos] = [-distToPaddlePlane+1+puckRadius, (yVel/xVel)*Math.abs((-distToPaddlePlane+1+puckRadius)-xPos)+yPos];\n            }\n\n            // update\n            [this.xVelecityPuck, this.yVelecityPuck] = [xVel, yVel];\n            return [xPos, yPos];\n        }\n        // paddle 2\n        else if(newX >= distToPaddlePlane-puckRadius) {\n            // only bounce if paddle is there\n            const distToCenterPaddle = (this.yPuck - this.paddle2Pos)/paddleWidth;\n            if(Math.abs(distToCenterPaddle) > 0.5+puckRadius/paddleWidth){\n                return [newX, this.yPuck+this.yVelecityPuck];\n            }\n\n            // calculate new velocities\n            const [xVel, yVel] = [-this.xSpeedBounceX(this.xVelecityPuck, distToCenterPaddle), this.ySpeedBounceX(this.yVelecityPuck, distToCenterPaddle)];\n\n            // calculate the ball's new position this tick\n            let xPos, yPos;\n            //  if its already inside the paddle simply change velocities and update position\n            if(this.xPuck >= distToPaddlePlane-puckRadius) {\n                [xPos, yPos] = [this.xPuck+xVel, this.yPuck+yVel];\n            }\n            //  otherwise simulate how the bounce would work given infinite tick rate\n            else {\n                // model how much more the puck should have traveled after the bounce\n                const percentTurnTraveled = Math.abs((distToPaddlePlane - Math.abs(this.xPuck)-puckRadius)/this.xVelecityPuck);\n                const percentMoreToTravel = 1 - percentTurnTraveled;\n                // find the x/y the puck would have hit the paddle\n                const projectedIntersectionY = (this.yVelecityPuck/this.xVelecityPuck)*(distToPaddlePlane-this.xPuck-puckRadius)+this.yPuck;\n\n                // model where the puck would have traveled to after the collision\n                [xPos, yPos] = [distToPaddlePlane+percentMoreToTravel*xVel-puckRadius, projectedIntersectionY+percentMoreToTravel*yVel];\n            }\n\n            // if the new position is still in the paddle, eject it\n            if(xPos >= distToPaddlePlane-puckRadius) {\n                [xPos, yPos] = [distToPaddlePlane-1-puckRadius, (yVel/xVel)*Math.abs((distToPaddlePlane-1-puckRadius)-xPos)+yPos];\n            }\n\n            // update\n            [this.xVelecityPuck, this.yVelecityPuck] = [xVel, yVel];\n            return [xPos, yPos];\n        }\n        else {\n            console.log('ERROR IN BOUNCEX');\n            return undefined;\n        }\n    }\n    xSpeedBounceX(oldSpeed, distToCenterPaddle) {\n        return Math.max(Math.abs(oldSpeed) + (-scaleLine*Math.abs(distToCenterPaddle) + scaleLine/4)*horzSpeedMod, puckMinSpeed);\n    }\n    ySpeedBounceX(oldSpeed, distToCenterPaddle) {\n        return oldSpeed*vertSpeedConservation + (scaleLine*distToCenterPaddle);\n    }\n\n    // helper function\n    // makes the bounds\n    makeBorders() {\n        return(\n            <>\n                <div className={\"horz-bound fill fill2\"} style={({top: `${topBound*gameToPercent-puckRadius*gameToPercent}%`})} />\n                <div className={\"horz-bound fill fill2\"} style={({top: `${botBound*gameToPercent+puckRadius*gameToPercent}%`})} />\n                <div className={\"vert-bound fill fill2\"} style={({left: `${-distToDeathPlane*gameToPercent - puckRadius*gameToPercent}%`})} />\n                <div className={\"vert-bound fill fill2\"} style={({left: `${distToDeathPlane*gameToPercent + puckRadius*gameToPercent}%`})} />\n            </>\n        );\n    }\n    // resets default game vars\n    resetGameVars() {\n        this.paddle1Pos = leftEyeStartOffset;\n        this.paddle2Pos = rightEyeStartOffset;\n        this.xPuck = 0;\n        this.yPuck = 0;\n        this.xVelecityPuck = puckStartSpeed;\n        this.yVelecityPuck = 0;\n        this.scoreLeft = 0;\n        this.scoreRight = 0;\n    }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './diagnostics/reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}